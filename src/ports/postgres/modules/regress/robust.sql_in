
/* ----------------------------------------------------------------------- *//**
 *
 * @file robust.sql_in
 *
 * @brief SQL functions for linear regression
 * @date January 2011
 *
 * @sa Calculates robust statistics for various regression models. 
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')


/**
@addtogroup grp_robust

@about

This method calculates robust variance (Huber white estimates) statistic of utilizing the a clustered sandwich estimator for linear regression, logistic regression, multinomial logistic regression, and cox proportional hazard models. It is useful in calculating variances in a dataset with potentially noisy outliers.


@input

The training data is expected to be of the following form:
<pre>{TABLE|VIEW} <em>sourceName</em> (
    <em>outputTable</em> VARCHAR,
    <em>regressionType </em> VARCHAR,
    <em>dependentVariable</em> VARCHAR,
    <em>independentVariable</em> VARCHAR,
    <em>coef</em> FLOAT8[] OR NULL,
)</pre>

If the coefficients are NULL then the function will compute the coeffiecents of the required regresison.
@usage


<b> The Full Interface</b>

<pre>
SELECT madlib.\ref robust_variance(
    <em>'source_table'</em>,        -- name of input table, VARCHAR
    <em>'out_table'</em>,           -- name of output table, VARCHAR
    <em>'regression_type'</em>,     -- type of regression (linear/logistic/multilogisitc) 
    <em>'dependent_varname'</em>,   -- dependent variable, VARCHAR
    <em>'independent_varname'</em>, -- dependent variable, VARCHAR
    <em>'coef'</em>,  							-- coef FLOAT8[] or NULL
);
</pre>

Here the <em>'independent_varname'</em> can be the name of a column, which contains
array of numeric values. It can also have a format of string 'array[1, x1, x2, x3]',
where <em>x1</em>, <em>x2</em> and <em>x3</em> are all column names.

Output is stored in the <em>out_table</em>:
<pre>
[ coef | std_err | stats | p_values |
+------+---------+-------+----------+
</pre>


@examp

@literature


[1] vce(cluster) function in STATA: http://www.stata.com/help.cgi?vce_option

[2] clustered estimators in R: http://people.su.se/~ma/clustering.pdf

@sa File robust.sql_in documenting the SQL functions.

@internal
@sa Namespace \ref madlib::modules::regress
    documenting the implementation in C++
@endinternal
*/
--------------------------- Robust Linear Regression ----------------------------------
CREATE TYPE MADLIB_SCHEMA.robust_linregr_result AS (
    std_err DOUBLE PRECISION[],
    t_stats DOUBLE PRECISION[],
    p_values DOUBLE PRECISION[]
);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_transition(
    state MADLIB_SCHEMA.bytea8,
    y DOUBLE PRECISION,
    x DOUBLE PRECISION[],
    coef DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_merge_states(
    state1 MADLIB_SCHEMA.bytea8,
    state2 MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

-- Final functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_final(
    state MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.robust_linregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief Compute robust regression diagnostic statistics.
 *
 * @param dependentVariable Column containing the dependent variable
 * @param independentVariables Column containing the array of independent variables
 * @param olsCoefficients Column containing the array of the OLS coefficients (as obtained by linregr)
 *
 * @par
 * To include an intercept in the model, set one coordinate in the
 * <tt>independentVariables</tt> array to 1.
 *
 * @return A composite value:
 *  - <tt>std_err FLOAT8[]</tt> - Array of huber-white standard errors,
 *    \f$ \mathit{se}(c_1), \dots, \mathit{se}(c_k) \f$
 *  - <tt>t_stats FLOAT8[]</tt> - Array of t-statistics, \f$ \boldsymbol t \f$
 *  - <tt>p_values FLOAT8[]</tt> - Array of p-values, \f$ \boldsymbol p \f$
 *
 * @usage
 *  - Get all the diagnostic statistics:\n
 * @usage
 *  <pre> SELECT (robust_linregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)).*
 *	FROM (
 *    SELECT linregr(<em>dependentVariable</em>, <em>independentVariables</em>).coef 
 *	) AS ols_coef, <em>sourceName</em> as src; 
 *  - Get a subset of the output columns, e.g., only the condition number 
 *  and the array of p-values \f$ \boldsymbol p \f$:
 *    <pre>SELECT (lr).robust_condition_no, (lr).robust_p_values
 *FROM (
 *  <pre> SELECT (robust_linregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)).*
 *	FROM (
 *    SELECT linregr(<em>dependentVariable</em>, <em>independentVariables</em>).coef 
 *	) AS ols_coef, <em>sourceName</em> as src
 *) AS subq;</pre>
 */

CREATE AGGREGATE MADLIB_SCHEMA.robust_linregr(
    /*+ "dependentVariable" */ DOUBLE PRECISION,
    /*+ "independentVariables" */ DOUBLE PRECISION[],
    /*+ "coef" */ DOUBLE PRECISION[]) (
    SFUNC=MADLIB_SCHEMA.robust_linregr_transition,
    STYPE=MADLIB_SCHEMA.bytea8,
    FINALFUNC=MADLIB_SCHEMA.robust_linregr_final,
    m4_ifdef(`__GREENPLUM__',`prefunc=MADLIB_SCHEMA.robust_linregr_merge_states,')
    INITCOND=''
);



/**
 * @internal
 * @bCompute the results of the sandwich estimator
 *     
 */
 
--DROP TYPE IF EXISTS MADLIB_SCHEMA.robust_logregr_result;
CREATE TYPE MADLIB_SCHEMA.robust_logregr_result AS (
    coef DOUBLE PRECISION[],
    std_err DOUBLE PRECISION[],
    z_stats DOUBLE PRECISION[],
    p_values DOUBLE PRECISION[]
);
 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_transition(
    state DOUBLE PRECISION[],
    y DOUBLE PRECISION,
    x DOUBLE PRECISION[],
    coef DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_merge_states(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_final(
    state DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.robust_logregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT; 

CREATE AGGREGATE MADLIB_SCHEMA.robust_logregr(
	DOUBLE PRECISION, /*+ y */
	DOUBLE PRECISION[], /*+ x */ 
    DOUBLE PRECISION[] /*+ coef */ ) (
    
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.robust_logregr_step_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.robust_logregr_step_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.robust_logregr_step_final,
    INITCOND='{0,0,0,0,0.0}'
);

--------------------------- INTERNAL ---------------------------------------
/**
  * @brief Return robust logistic regression estimates given a set of coefficients
**/
CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_logregr_result(
     source_table         VARCHAR       -- name of input  table
   , dependent_varname    VARCHAR       -- name of dependent variable
   , independent_varname  VARCHAR       -- name of independent variable
   , logregr_coeffs       DOUBLE PRECISION[]  -- coeffs from linear regression
)
RETURNS MADLIB_SCHEMA.robust_logregr_result AS $$
DECLARE
robust_value MADLIB_SCHEMA.robust_logregr_result;
BEGIN
  
	EXECUTE '
    SELECT (MADLIB_SCHEMA.robust_logregr('
          || dependent_varname    || ' , '
          || independent_varname  || ' , '
          || 'ARRAY[' || array_to_string(logregr_coeffs, ',') || '])
     	).* FROM ' || source_table
	INTO robust_value;
  RETURN robust_value;
END
$$ LANGUAGE plpgsql VOLATILE;

/**
  * @brief Return insert string for robust logistic regression 
**/

CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_logregr_insert_string(
    robust_log_rst MADLIB_SCHEMA.robust_logregr_result,
    out_table TEXT
)
RETURNS VARCHAR AS $$
DECLARE 
  insert_string VARCHAR;
BEGIN
  insert_string := 'INSERT INTO ' || out_table || ' VALUES ('; 
  insert_string := insert_string  || 
            CASE 
              WHEN (robust_log_rst).coef is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).coef, ',')     || '], '
            END             || 
            CASE 
              WHEN (robust_log_rst).std_err is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).std_err, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_log_rst).z_stats is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).z_stats, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_log_rst).p_values is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).p_values, ',') || '] '
            END;
  RETURN insert_string; 
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- INTERNAL ---------------------------------------
/**
  * @brief Return robust linear regression estimates given a set of coefficients
**/
CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_linregr_result(
     source_table         VARCHAR       -- name of input  table
   , dependent_varname    VARCHAR       -- name of dependent variable
   , independent_varname  VARCHAR       -- name of independent variable
   , linregr_coeffs       DOUBLE PRECISION[]  -- coeffs from linear regression
)
RETURNS MADLIB_SCHEMA.robust_linregr_result AS $$
DECLARE
robust_value MADLIB_SCHEMA.robust_linregr_result;
BEGIN
	EXECUTE '
    SELECT (MADLIB_SCHEMA.robust_linregr('
          || dependent_varname    || ' , '
          || independent_varname  || ' , '
          || 'ARRAY[' || array_to_string(linregr_coeffs, ',') || '])
			).* FROM ' || source_table
	INTO robust_value;
  RETURN robust_value;
END
$$ LANGUAGE plpgsql VOLATILE;

/**
  * @brief Return insert string for robust linear regression 
**/

CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_linregr_insert_string(
    robust_lin_rst		MADLIB_SCHEMA.robust_linregr_result
  , linregr_coeffs    DOUBLE PRECISION[]  -- coeffs from linear regression
  , out_table TEXT
)
RETURNS VARCHAR AS $$
DECLARE 
  insert_string VARCHAR;
BEGIN
  insert_string := 'INSERT INTO ' || out_table || ' VALUES ('; 
  insert_string := insert_string  || 
		CASE 
			WHEN linregr_coeffs is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string(linregr_coeffs, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).std_err is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).std_err, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).t_stats is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).t_stats, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).p_values is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).p_values, ',') || ']'
		END;
  RETURN insert_string; 
END;
$$ LANGUAGE plpgsql VOLATILE;


/**
  @brief Compute robust regression diagnostic statistics.
 
*/
CREATE FUNCTION MADLIB_SCHEMA.robust_variance(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , regression_type						VARCHAR       -- type of regression 
   , dependent_varname          VARCHAR       -- name of dependent variable
   , independent_varname        VARCHAR       -- name of independent variable
   , coef												DOUBLE PRECISION[]      --regression coefficients 
  )
RETURNS VOID AS $$
DECLARE
insert_string       VARCHAR;
regr_coef			DOUBLE PRECISION[];
robust_lin_rst      MADLIB_SCHEMA.robust_linregr_result;
robust_log_rst		MADLIB_SCHEMA.robust_logregr_result;
BEGIN
	IF (source_table IS NULL OR source_table = '') THEN
	RAISE EXCEPTION 'Invalid input table name given.';
	END IF;
	IF (out_table IS NULL OR out_table = '') THEN
	RAISE EXCEPTION 'Invalid output table name given.';
	END IF;
	IF (dependent_varname IS NULL OR dependent_varname = '') THEN
	RAISE EXCEPTION 'Invalid dependent variable name given.';
	END IF;
	IF (independent_varname IS NULL OR independent_varname = '') THEN
	RAISE EXCEPTION 'Invalid independent variable name given.';
	END IF;
	-- create output table with appropriate column names
	EXECUTE 'DROP TABLE IF EXISTS ' || out_table;
	RAISE NOTICE 'Creating table';		
	EXECUTE '
	CREATE TABLE ' || out_table || ' (
			coef DOUBLE PRECISION[],
			std_err DOUBLE PRECISION[],
			t_stats DOUBLE PRECISION[],
			p_values DOUBLE PRECISION[])';
	-- Separate wrapper for each function 
	IF (regression_type = 'linear') THEN
	
		IF (coef IS NULL) THEN
			-- Run the regression if the coefficients are not provided 
			EXECUTE '
					SELECT (MADLIB_SCHEMA.linregr('
								|| dependent_varname    || ' , '
								|| independent_varname  || ')
						).coef FROM ' || source_table
				INTO regr_coef;
		ELSE
				regr_coef := coef;	
		END IF;
    
		-- compute linear regression and heteroskedasticity values (if required)
    robust_lin_rst := MADLIB_SCHEMA.__internal_get_robust_linregr_result(
                    source_table, dependent_varname, independent_varname, regr_coef);
		insert_string := MADLIB_SCHEMA.__internal_get_robust_linregr_insert_string(
                    robust_lin_rst, regr_coef, out_table);
    -- Ensure Infinity and NaN are cast properly
    insert_string := REGEXP_REPLACE(insert_string, 'Infinity', 
                                    '''Infinity''::double precision', 'gi');
    insert_string := REGEXP_REPLACE(insert_string, 'NaN', 
                                    '''NaN''::double precision', 'gi');
		-- complete the sql string and execute
		EXECUTE insert_string || ')';
	ElSIF (regression_type = 'logistic') THEN
	
		IF (coef IS NULL) THEN
			-- Run the regression if the coefficients are not provided 
			EXECUTE '
					--DROP TABLE IF EXISTS __tempTable;
					SELECT MADLIB_SCHEMA.logregr_train('
								|| ' '''||source_table||''' ' || ','
								|| ' '''||'__tempTable'||''' ' || ','
								|| ' '''||dependent_varname ||''' ' || ' , '
								|| ' '''||independent_varname||''' '|| ')';
					--SELECT coef from __tempTable INTO regr_coef;
					EXECUTE 'SELECT coef from __tempTable' INTO regr_coef;
					--regr_coef := SELECT coef from __tempTable;
					RAISE NOTICE '%', regr_coef;
					DROP TABLE IF EXISTS __tempTable;
		ELSE
				regr_coef := coef;	
		END IF;

		RAISE NOTICE 'Computing logistic regression coef';		
    -- compute linear regression and heteroskedasticity values (if required)
    robust_log_rst := MADLIB_SCHEMA.__internal_get_robust_logregr_result(
                    source_table, dependent_varname, independent_varname, regr_coef);
		RAISE NOTICE 'Computing string';		
		insert_string := MADLIB_SCHEMA.__internal_get_robust_logregr_insert_string(
                    robust_log_rst, out_table);
		RAISE NOTICE 'Calling cs_create_job(%)', 1;		
		RAISE NOTICE '%', insert_string;		
    -- Ensure Infinity and NaN are cast properly
    insert_string := REGEXP_REPLACE(insert_string, 'Infinity', 
                                    '''Infinity''::double precision', 'gi');
    insert_string := REGEXP_REPLACE(insert_string, 'NaN', 
                                    '''NaN''::double precision', 'gi');
		-- complete the sql string and execute
		EXECUTE insert_string || ')';
		
  ELSE
      RAISE EXCEPTION 'No such regression type found. Must be (linear/logistic)';
  END IF;

END;
$$ LANGUAGE plpgsql VOLATILE;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_transition(
    state DOUBLE PRECISION[],
    y INTEGER,
    numcat INTEGER,
    x DOUBLE PRECISION[],
    coef DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_merge_states(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_final(
    state DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.robust_logregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT; 

CREATE AGGREGATE MADLIB_SCHEMA.robustMLogregr(
	INTEGER, /*+ y */
	INTEGER, /*numcat*/
	DOUBLE PRECISION[], /*+ x */ 
    DOUBLE PRECISION[] /*+ coef */ ) (
    
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.mlogregr_robust_step_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.mlogregr_robust_step_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.mlogregr_robust_step_final,
    INITCOND='{0,0,0,0,0.0}'
);

