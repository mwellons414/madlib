/* ----------------------------------------------------------------------- *//**
 *
 * @file robust.sql_in
 *
 * @brief SQL functions for linear regression
 * @date January 2011
 *
 * @sa Calculates robust statistics for various regression models. 
 *
 *//* ----------------------------------------------------------------------- */

m4_include(`SQLCommon.m4')


/**
@addtogroup grp_robust

@about


When doing regression analysis, we are sometimes interested in the variance of the computed coefficients \f$ \boldsymbol  c \f$.  While the built-in regression functions provide variance estimates, we may prefer a <i> robust </i> variance estimate.  
 
The robust variance calculation can be expressed in a sandwich formation, which is the form
\f[
    S( \boldsymbol c) = B( \boldsymbol c) M( \boldsymbol c) B( \boldsymbol c)
\f]
where \f$ B( \boldsymbol c)\f$ and \f$ M( \boldsymbol c)\f$ are matrices.  The \f$ B( \boldsymbol c)\f$ matrix, 
also known as the bread, is relatively straight forward, and can be computed as
\f[
B( \boldsymbol c) = n\left(\sum_i^n -H(y_i, x_i, \boldsymbol  c) \right)^{-1}
\f]
where \f$H\f$ is the hessian matrix.  

The \f$ M( \boldsymbol c)\f$ matrix has several variation, each with different robustness properties.  
The form implemented here is the Huber-White sandwich operator, which takes the form
\f[
M_{H} =\frac{1}{n} \sum_i^n \psi(y_i,x_i,  \boldsymbol c)^T  \psi(y_i,x_i,  \boldsymbol c).
\f]


The above method for calculating robust variance (Huber-White estimates) is implemented for linear regression, logistic regression, and multinomial logistic regression. It is useful in calculating variances in a dataset with potentially noisy outliers.  The Huber-White implemented here is identical to the "HC0" sandwich operator in the R module "sandwich".   


The interface for robust linear and logistic regression are identical, including the help and usage functions.  

@input

The training data is expected to be of the following form:
<pre>{TABLE|VIEW} <em>sourceName</em> (
    <em>outputTable</em> VARCHAR,
    <em>regressionType </em> VARCHAR,
    <em>dependentVariable</em> VARCHAR,
    <em>independentVariable</em> VARCHAR
)</pre>

@usage


<b> The Full Interface</b>

<pre>
SELECT \ref madlib.robust_variance_linregr(
    <em>'source_table'</em>,        -- name of input table, VARCHAR
    <em>'out_table'</em>,           -- name of output table, VARCHAR
    <em>'dependent_varname'</em>,   -- dependent variable, VARCHAR
    <em>'independent_varname'</em>, -- independent variables, VARCHAR
    <em>'grouping_cols'</em> 		-- [OPTIONAL] grouping variables, VARCHAR
);
</pre>
OR
<pre>
SELECT \ref madlib.robust_variance_logregr(
    <em>'source_table'</em>,        -- name of input table, VARCHAR
    <em>'out_table'</em>,           -- name of output table, VARCHAR
    <em>'dependent_varname'</em>,   -- dependent variable, VARCHAR
    <em>'independent_varname'</em>, -- independent variables, VARCHAR
    <em>'grouping_cols'</em>, 		-- [OPTIONAL] grouping variables, VARCHAR
    <em>max_iter</em>,			-- [OPTIONAL] Integer identifying the maximum iterations used by the logistic regression solver.  Default is 20, Integer
    <em>'optimizer'</em>,			-- [OPTIONAL] String identifying the optimizer used in the logistic regression.  See the documentation in the logistic regression for the available options.  Default is irls.  VARCHAR
	<em>tolerance</em>,			-- [OPTIONAL] Float identifying the tolerance of the logistic regression optimizer. Default is 0.0001.  DOUBLE PRECISION
	<em>print_warnings</em>		-- [OPTIONAL] Boolean specifying if the regression fit should print any warning messages.  Default is false. BOOLEAN
);
</pre>
OR
<pre>
SELECT \ref madlib.robust_variance_mlogregr(
    <em>'source_table'</em>,        -- name of input table, VARCHAR
    <em>'out_table'</em>,           -- name of output table, VARCHAR
    <em>'dependent_varname'</em>,   -- dependent variable, VARCHAR
    <em>'independent_varname'</em>, -- independent variables, VARCHAR
    <em>'ref_category'</em>,        -- [OPTIONAL] Integer specifying the reference category. Default is 0. INTEGER
    <em>'grouping_cols'</em>, 		-- [OPTIONAL] grouping variables, VARCHAR
);
</pre>
Here the <em>'independent_varname'</em> can be the name of a column, which contains
array of numeric values. It can also have a format of string 'array[1, x1, x2, x3]',
where <em>x1</em>, <em>x2</em> and <em>x3</em> are all column names.

Output is stored in the <em>out_table</em>:
<pre>
[ coef | std_err | (z/t)-stats | p_values |
+------+---------+-------+----------+
</pre>


@examp


-#  For function summary information. Run 
@verbatim
sql> select robust_variance_{linregr OR logregr OR mlogregr}('help');
OR
sql> select robust_variance_{linregr OR logregr OR mlogregr}();
OR
sql> select robust_variance_{linregr OR logregr OR mlogregr}('?');
@endverbatim

-#  For function usage information. 
@verbatim
sql> select robust_variance_{linregr OR logregr OR mlogregr}('usage');
@endverbatim
-# Create the sample data set:
@verbatim
sql> SELECT * FROM data;
 id | second_attack | treatment | trait_anxiety 
----+---------------+-----------+---------------
  1 |             1 |         1 |            70
  3 |             1 |         1 |            50
  5 |             1 |         0 |            40
  7 |             1 |         0 |            75
  9 |             1 |         0 |            70
 11 |             0 |         1 |            65
 13 |             0 |         1 |            45
 15 |             0 |         1 |            40
 17 |             0 |         0 |            55
...
@endverbatim
-# Run the logistic regression function and then compute the robust logistic variance of the regression:
@verbatim
sql> select robust_variance_logregr('patients', 'newTable',  'second_attack', 'ARRAY[1, treatment, trait_anxiety]'); 
sql> select * from newTable;
coef           | {11.962748350258,1.37269168529894,0.00285507335100035}
std_err        | {3.45872062333141,1.17161925782182,0.053432886418388}
z_stats        | {-1.839833462942,-0.874094587942144,2.22793348156965}
p_values       | {0.0657926909738772,0.382066744586027,0.0258849510756295}
@endverbatim


@literature


[1] vce(cluster) function in STATA: http://www.stata.com/help.cgi?vce_option

[2] clustered estimators in R: http://people.su.se/~ma/clustering.pdf

[3] Achim Zeileis: Object-oriented Computation of Sandwich Estimators. 
	Research Report Series / Department of Statistics and Mathematics, 37. 
	Department of Statistics and Mathematics, WU Vienna University of Economics and Business, Vienna.
	http://cran.r-project.org/web/packages/sandwich/vignettes/sandwich-OOP.pdf

@sa File robust.sql_in documenting the SQL functions.

@internal
@sa Namespace \ref madlib::modules::regress
    documenting the implementation in C++
@endinternal
*/

/**
 * @internal
 * @bDoes error checking on the input for the robust variance regressions for the mandatory inputs.  
 *     
 */
 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_input_checking(
  source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_varname          VARCHAR       -- name of dependent variable
   , independent_varname  VARCHAR       -- name of independent variable
)
RETURNS VOID AS $$
BEGIN
	IF (source_table IS NULL OR source_table = '') THEN
	  RAISE EXCEPTION 'Invalid input table name given.';
	END IF;
	IF (NOT MADLIB_SCHEMA.__table_exists(source_table)) THEN
	  RAISE EXCEPTION 'Input table name does not exist.';
	END IF;
	IF (out_table IS NULL OR out_table = '') THEN
	  RAISE EXCEPTION 'Invalid output table name given.';
	END IF;
	IF (MADLIB_SCHEMA.__table_exists(out_table)) THEN
	  RAISE EXCEPTION 'Output table name already exists. Drop the table before calling the function.';
	END IF;
	IF (independent_varname IS NULL OR independent_varname = '') THEN
	  RAISE EXCEPTION 'Invalid independent variable name given.';
	END IF;
	IF (dependent_varname IS NULL OR dependent_varname = '') THEN
	  RAISE EXCEPTION 'Invalid dependent variable name given.';
	END IF;
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- Robust Linear Regression ----------------------------------

CREATE TYPE MADLIB_SCHEMA.robust_linregr_result AS (
    coef      DOUBLE PRECISION[],
    std_err   DOUBLE PRECISION[],
    t_stats   DOUBLE PRECISION[],
    p_values  DOUBLE PRECISION[]
);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_transition(
    state   MADLIB_SCHEMA.bytea8,
    y       DOUBLE PRECISION,
    x       DOUBLE PRECISION[],
    coef    DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_merge_states(
    state1 MADLIB_SCHEMA.bytea8,
    state2 MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.bytea8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

-- Final functions
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_linregr_final(
    state MADLIB_SCHEMA.bytea8)
RETURNS MADLIB_SCHEMA.robust_linregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

/**
 * @brief Compute robust regression diagnostic statistics for linear regression.
 *
 * @param dependentVariable Column containing the dependent variable
 * @param independentVariables Column containing the array of independent variables
 * @param coef Column containing the array of the OLS coefficients (as obtained by linregr)
 *
 * @par
 * To include an intercept in the model, set one coordinate in the
 * <tt>independentVariables</tt> array to 1.
 *
 * @return A composite value:
 *  - <tt>std_err FLOAT8[]</tt> - Array of huber-white standard errors,
 *    \f$ \mathit{se}(c_1), \dots, \mathit{se}(c_k) \f$
 *  - <tt>t_stats FLOAT8[]</tt> - Array of t-statistics, \f$ \boldsymbol t \f$
 *  - <tt>p_values FLOAT8[]</tt> - Array of p-values, \f$ \boldsymbol p \f$
 *
 * @usage
 *  - Get all the diagnostic statistics:\n
 * 
 *  <pre> SELECT (robust_linregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)).*
 *	FROM (
 *    SELECT linregr(<em>dependentVariable</em>, <em>independentVariables</em>).coef 
 *	) AS ols_coef, <em>sourceName</em> as src; 
 * </pre>
 *  - Get a subset of the output columns, e.g., only the condition number 
 *  and the array of p-values \f$ \boldsymbol p \f$:
 *    <pre>SELECT (lr).robust_condition_no, (lr).robust_p_values
 *FROM ( 
 * </pre>
 *  <pre> SELECT (robust_linregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)).*
 *	FROM (
 *    SELECT linregr(<em>dependentVariable</em>, <em>independentVariables</em>).coef 
 *	) AS ols_coef, <em>sourceName</em> as src
 *) AS subq;</pre>
 */

CREATE AGGREGATE MADLIB_SCHEMA.robust_linregr(
    /*+ "dependentVariable" */ DOUBLE PRECISION,
    /*+ "independentVariables" */ DOUBLE PRECISION[],
    /*+ "coef" */ DOUBLE PRECISION[]) (
    SFUNC=MADLIB_SCHEMA.robust_linregr_transition,
    STYPE=MADLIB_SCHEMA.bytea8,
    FINALFUNC=MADLIB_SCHEMA.robust_linregr_final,
    m4_ifdef(`__GREENPLUM__',`prefunc=MADLIB_SCHEMA.robust_linregr_merge_states,')
    INITCOND=''
);

--------------------------- INTERNAL ---------------------------------------
/**
  * @brief Return robust linear regression estimates given a set of coefficients
**/
CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_linregr_result(
     source_table         VARCHAR       -- name of input  table
   , dependent_varname    VARCHAR       -- name of dependent variable
   , independent_varname  VARCHAR       -- name of independent variable
   , linregr_coeffs       DOUBLE PRECISION[]  -- coeffs from linear regression
)
RETURNS MADLIB_SCHEMA.robust_linregr_result AS $$
DECLARE
robust_value MADLIB_SCHEMA.robust_linregr_result;
BEGIN
	EXECUTE '
    SELECT (MADLIB_SCHEMA.robust_linregr('
          || dependent_varname    || ' , '
          || independent_varname  || ' , '
          || 'ARRAY[' || array_to_string(linregr_coeffs, ',') || '])
			).* FROM ' || source_table
	INTO robust_value;
  RETURN robust_value;
END
$$ LANGUAGE plpgsql VOLATILE;

/**
  * @brief Return insert string for robust linear regression 
**/

CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_linregr_insert_string(
    robust_lin_rst		MADLIB_SCHEMA.robust_linregr_result
  , linregr_coeffs    DOUBLE PRECISION[]  -- coeffs from linear regression
  , out_table TEXT
)
RETURNS VARCHAR AS $$
DECLARE 
  insert_string VARCHAR;
BEGIN
  insert_string := 'INSERT INTO ' || out_table || ' VALUES ('; 
  insert_string := insert_string  || 
		CASE 
			WHEN linregr_coeffs is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string(linregr_coeffs, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).std_err is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).std_err, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).t_stats is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).t_stats, ',')  || '], '
		END             ||
		CASE 
			WHEN (robust_lin_rst).p_values is NULL
			THEN '''{}'','
			ELSE 'ARRAY[' || array_to_string((robust_lin_rst).p_values, ',') || ']'
		END;
  RETURN insert_string; 
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- Interface ----------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_linregr(
     usage_string VARCHAR                               -- usage string
)
RETURNS VARCHAR AS $$
DECLARE
insert_string       VARCHAR;
BEGIN
	IF (usage_string = ''  OR usage_string = 'help' OR usage_string = '?') THEN
    insert_string := '' || 
    E'Summary \n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' Functionality: Calculate Huber-White robust statistics for linear regression\n' || 	
    E' The function first runs the regression to calculate the \n' ||
    E'     coefficients and uses them to calculate the robust statistics \n' || 	
    E' The functions robust_variance_linregr() and robust_variance_logregr() have nearly identical interfaces\n' || 	
    E' SELECT {schema_madlib}.robust_variance_linregr(''source_table'' \n' || 
    E'                                       ,''output_table'' \n' || 
    E'                                       ,''dependent_variable'' \n' || 
    E'                                       ,''independent_variable'' \n' ||
    E'                                       ,''group_cols'' \n' ||
    E'                                       );\n' || 
    E'For more details on function usage:  \n' || 
    E'SELECT {schema_madlib}.robust_variance_linregr(''usage'') \n';
  ElSIF (usage_string  = 'usage') THEN
    insert_string := '' || 
    E'Usage\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' To use this function  \n' || 	
    E' SELECT {schema_madlib}.robust_variance_linregr( \n' ||
    E' ''source_table'',         -- Name of data table          \n' || 
    E' ''output_table'',         -- Name of result table \n' || 
    E' ''dependent_variable'',   -- Name of column for dependent variables\n' || 
    E' ''independent_variable'', -- Name of column for independent variables\n' || 
    E'                               (can be any SQL expression that evaluates to an array) \n' || 
    E' ''group_cols'',           -- [OPTIONAL] Comma separated string with columns to group by.  Default is NULL. \n' || 
    E' );\n' || 
    E'\n' || 
    E'Output:\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' The output table (''output_table'' above) has the following columns\n' || 	
    E' ''coef''    DOUBLE PRECISION[],  -- Coefficients of regression \n' || 
    E' ''std_err''  DOUBLE PRECISION[], -- Huber-White standard errors\n' || 
    E' ''stats''    DOUBLE PRECISION[], -- T-stats of the standard errors\n' || 
    E' ''p_values'' DOUBLE PRECISION[], -- p-values of the standard errors\n' || 
    E'\n' || 
    E'';
  ELSE
    insert_string := 'No such option. Run SELECT {schema_madlib}.robust_variance_linregr()';
  END IF;
  RETURN insert_string;
END;
$$ LANGUAGE plpgsql VOLATILE;



CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_linregr()
RETURNS VARCHAR AS $$
BEGIN
  RETURN MADLIB_SCHEMA.robust_variance_linregr('');
END;
$$ LANGUAGE plpgsql VOLATILE;

/**
  * @brief Robust linear regression with default fit regression behaviour & no grouping
 **/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_linregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_linregr(
                              source_table,
                              out_table,
                              dependent_variable,
                              independent_variable,
                              NULL);
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- Robust Linear Regression ----------------------------------

/**
  * @brief Robust linear regression function subcall
 **/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_linregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_varname          VARCHAR       -- name of dependent variable
   , input_independent_varname        VARCHAR       -- name of independent variable
   , input_group_cols           VARCHAR       -- grouping columns
  )
RETURNS VOID AS $$
DECLARE
  insert_string         VARCHAR;
  group_cols            VARCHAR[];
  regr_coef		      	  DOUBLE PRECISION[];
  robust_lin_rst        MADLIB_SCHEMA.robust_linregr_result;
  table_creation_string       VARCHAR;
  group_string                VARCHAR;
  where_group_string            VARCHAR;
  actual_table_name           VARCHAR;
  input_table_name            VARCHAR[];
  group_array_length          INTEGER;
  each_group                  INTEGER;
  robust_linregr_fitting_rst  VARCHAR;
  temp_table                  VARCHAR;
  col_data_type               VARCHAR;
  schema_name                 VARCHAR;
  sql                         VARCHAR;
  old_msg_level         TEXT;
  independent_varname   VARCHAR;
BEGIN
  EXECUTE 'SELECT setting FROM pg_settings WHERE name=''client_min_messages''' INTO old_msg_level;
  EXECUTE 'SET client_min_messages TO warning';
  	
  PERFORM MADLIB_SCHEMA.robust_input_checking(source_table, out_table, dependent_varname, input_independent_varname);	
  independent_varname := input_independent_varname; 
  
  --This code should be added back in should '*' support be implemented
  /*IF (input_independent_varname = '*') THEN
	  independent_varname := MADLIB_SCHEMA.__internal_get_col_names_except_dep_variable(source_table, input_independent_varname);
	ELSE
	  independent_varname := input_independent_varname; 
  	END IF;*/
  
  
  IF (input_group_cols IS NULL)
	THEN
    -------------------------------------------------------------------------
    -- No grouping columns: Run regular robust variance estimates
    -------------------------------------------------------------------------
	  -- Step 1: Create output table with appropriate column names
    EXECUTE '
    CREATE TABLE ' || out_table || ' (
        coef DOUBLE PRECISION[],
        std_err DOUBLE PRECISION[],
        t_stats DOUBLE PRECISION[],
        p_values DOUBLE PRECISION[])';
    -- Step 2: Run the regression if the coefficients are not provided 
    EXECUTE '
        SELECT (MADLIB_SCHEMA.linregr('
              || dependent_varname    || ' , '
              || independent_varname  || ')
          ).coef FROM ' || source_table
      INTO regr_coef;
    
      -- Step 3: Perform the robust linear regression
    robust_lin_rst := MADLIB_SCHEMA.__internal_get_robust_linregr_result(
                    source_table, dependent_varname, independent_varname, regr_coef);
    
    -- Step 4: Insert into output table & cast infinity and nan
    insert_string := MADLIB_SCHEMA.__internal_get_robust_linregr_insert_string(
                    robust_lin_rst, regr_coef, out_table);
    insert_string := REGEXP_REPLACE(insert_string, 'Infinity', 
                                    '''Infinity''::double precision', 'gi');
    insert_string := REGEXP_REPLACE(insert_string, 'NaN', 
                                    '''NaN''::double precision', 'gi');
    EXECUTE insert_string || ')';

  ELSE
    -------------------------------------------------------------------------
    -- Grouping columns: Run robust variance estimates for each group
    -------------------------------------------------------------------------
    
    -- Step 1: Prepare the group columns 
    -------------------------------------------------------------------------
    group_cols = MADLIB_SCHEMA._string_to_array(input_group_cols);
    group_array_length = array_upper(group_cols, 1);

    input_table_name = regexp_split_to_array(source_table, E'\\.');
    IF array_upper(input_table_name, 1) = 1 THEN
      actual_table_name = input_table_name[1];
      schema_name  := current_schema();
    ELSIF array_upper(input_table_name, 1) = 2 THEN
      actual_table_name = input_table_name[2];
      schema_name  = input_table_name[1];
    ELSE
      RAISE EXCEPTION 'Incorrect input source table name provided';
    END IF;

    -- Check that each grouping column exists
    FOR each_group in 1 .. group_array_length
    LOOP
      if NOT MADLIB_SCHEMA.check_if_col_exists(source_table, 
                                    group_cols[each_group]) THEN
            RAISE EXCEPTION 'Grouping column % does not exist', 
                                    group_cols[each_group];
      END IF;
    END LOOP;

    table_creation_string := 'CREATE TABLE ' || out_table || '(';
    FOR each_group in 1 .. group_array_length
    LOOP
        -- create a string that makes list of
        EXECUTE 'SELECT data_type FROM information_schema.columns
                 WHERE
                      table_schema = ''' || schema_name || '''
                      AND table_name = ''' || actual_table_name || '''
                      AND column_name= ''' || group_cols[each_group] || ''''
        INTO col_data_type;

        table_creation_string := table_creation_string
                                || group_cols[each_group]
                                || ' ' || col_data_type || ',';
    END LOOP;
   
    -- finish creating the output table
    EXECUTE table_creation_string || '
            coef DOUBLE PRECISION[],
            std_err DOUBLE PRECISION[],
            t_stats DOUBLE PRECISION[],
            p_values DOUBLE PRECISION[])';
    
    -- Step 2: Perform the linear regression on groups
    -------------------------------------------------------------------------
		temp_table := MADLIB_SCHEMA.__unique_string(); 
    PERFORM MADLIB_SCHEMA.linregr_train(source_table, 
                                        temp_table,
                                        dependent_varname,
                                        independent_varname,
                                        input_group_cols);
    
    -- Note: We need to alter the names on the output tables for linregr_train
    -- so that they don't clash with the robust_variance_linregr output tables
    -- This name changing is required to construct queries when the regressor
    -- is also being grouped by. I don't know why anyone would do that but 
    -- it should be a mathematically valid operation.
    FOR each_group in 1 .. group_array_length
    LOOP
        EXECUTE 'ALTER TABLE ' || temp_table || ' RENAME COLUMN ' || 
                 group_cols[each_group] || ' TO lin_regr_' 
                || group_cols[each_group];
    END LOOP;
                                    
    -- Step 3: Prepare the grouping strings 
    group_string := '';
    FOR each_group in 1 .. (group_array_length-1)
    LOOP
        group_string := group_string || 
                        actual_table_name || '.' || 
                        group_cols[each_group] || ',';
    END LOOP;
    group_string := group_string || 
                    actual_table_name || '.' || 
                    group_cols[group_array_length];

    -- Where clause string
    where_group_string := '';
    FOR each_group in 1 .. (group_array_length-1)
    LOOP
        where_group_string := where_group_string || '(' || 
                        temp_table || '.lin_regr_' || 
                        group_cols[each_group] || ' = ' || 
                        actual_table_name || '.' || 
                        group_cols[each_group] || ') AND ';
    END LOOP;
    where_group_string := where_group_string || '(' || 
                    temp_table || '.lin_regr_' || 
                    group_cols[group_array_length] || ' = ' || 
                    actual_table_name || '.' || 
                    group_cols[group_array_length] || ')';

    -- Step 4: Put robust statistics into the out table 
    EXECUTE 
      'INSERT INTO ' || out_table || '
        SELECT ' || group_string || ', (result).coef, (result).std_err,
                                       (result).t_stats, (result).p_values
        FROM (
            SELECT
                '|| group_string ||',
                MADLIB_SCHEMA.robust_linregr('|| 
                    dependent_varname ||','|| 
                    independent_varname || ', coef) AS result' || 
            ' FROM '|| source_table || ',' || temp_table || 
            ' WHERE '|| where_group_string ||
            ' GROUP BY '|| group_string || ')' || actual_table_name;
     EXECUTE 'DROP TABLE IF EXISTS ' || temp_table;
  END IF;
  --Restore message settings
  EXECUTE 'SET client_min_messages TO '|| old_msg_level;
END;
$$ LANGUAGE plpgsql VOLATILE;


--------------------------- ROBUST LOGISTIC REGRESSION ---------------------------------------


/**
 * @internal
 * @bCompute the results of the Huber-White sandwich estimator
 *     
 */
 
--DROP TYPE IF EXISTS MADLIB_SCHEMA.robust_logregr_result;
CREATE TYPE MADLIB_SCHEMA.robust_logregr_result AS (
    coef DOUBLE PRECISION[],
    std_err DOUBLE PRECISION[],
    z_stats DOUBLE PRECISION[],
    p_values DOUBLE PRECISION[]
);
 
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_transition(
    state DOUBLE PRECISION[],
    y BOOLEAN,
    x DOUBLE PRECISION[],
    coef DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_merge_states(
    state1 DOUBLE PRECISION[],
    state2 DOUBLE PRECISION[])
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_logregr_step_final(
    state DOUBLE PRECISION[])
RETURNS MADLIB_SCHEMA.robust_logregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT; 


/**
 * @brief Compute robust regression diagnostic statistics for logistic regression.
 *
 * @param dependentVariable Column containing the dependent variable
 * @param independentVariables Column containing the array of independent variables
 * @param coef Column containing the array of the  coefficients (as obtained by logregr)
 *
 * @par
 * To include an intercept in the model, set one coordinate in the
 * <tt>independentVariables</tt> array to 1.
 *
 * @return A composite value:
 *  - <tt>coef FLOAT8[] </tt> - The coefficients for the regression
 *  - <tt>std_err FLOAT8[]</tt> - Array of huber-white standard errors,
 *    \f$ \mathit{se}(c_1), \dots, \mathit{se}(c_k) \f$
 *  - <tt>z_stats FLOAT8[]</tt> - Array of t-statistics, \f$ \boldsymbol t \f$
 *  - <tt>p_values FLOAT8[]</tt> - Array of p-values, \f$ \boldsymbol p \f$
 *
 * @usage
 *  - Get all the diagnostic statistics:\n
 *
 *  <pre> SELECT robust_logregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)
 *	FROM <em>dataTable</em>; 
 * </pre>
 */

CREATE AGGREGATE MADLIB_SCHEMA.robust_logregr(
	  /*+ "dependentVariable" */ BOOLEAN, 
	  /*+ "independentVariables" */  DOUBLE PRECISION[], 
    /*+ "coef" */ DOUBLE PRECISION[] ) (
    
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.robust_logregr_step_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.robust_logregr_step_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.robust_logregr_step_final,
    INITCOND='{0,0,0,0,0.0}'
);

--------------------------- INTERNAL ---------------------------------------
/**
  * @brief Return robust logistic regression estimates given a set of coefficients
**/
CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_logregr_result(
     source_table         VARCHAR       -- name of input  table
   , dependent_varname    VARCHAR       -- name of dependent variable
   , independent_varname  VARCHAR       -- name of independent variable
   , logregr_coeffs       DOUBLE PRECISION[]  -- coeffs from logear regression
)
RETURNS MADLIB_SCHEMA.robust_logregr_result AS $$
DECLARE
robust_value MADLIB_SCHEMA.robust_logregr_result;
BEGIN
	EXECUTE 'SELECT (MADLIB_SCHEMA.robust_logregr(('|| dependent_varname  || ' )::BOOLEAN, '|| independent_varname  || ' , '|| 'ARRAY[' || array_to_string(logregr_coeffs, ',') || '])).* FROM ' || source_table
	INTO robust_value;
  RETURN robust_value;
END
$$ LANGUAGE plpgsql VOLATILE;

/**
  * @brief Return insert string for robust logistic regression 
**/

CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_logregr_insert_string(
    robust_log_rst MADLIB_SCHEMA.robust_logregr_result,
    out_table TEXT
)
RETURNS VARCHAR AS $$
DECLARE 
  insert_string VARCHAR;
BEGIN
  insert_string := 'INSERT INTO ' || out_table || ' VALUES ('; 
  insert_string := insert_string  || 
            CASE 
              WHEN (robust_log_rst).coef is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).coef, ',')     || '], '
            END             || 
            CASE 
              WHEN (robust_log_rst).std_err is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).std_err, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_log_rst).z_stats is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).z_stats, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_log_rst).p_values is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_log_rst).p_values, ',') || '] '
            END;
  RETURN insert_string; 
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- Interface ----------------------------------

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     usage_string VARCHAR                               -- usage string
)
RETURNS VARCHAR AS $$
DECLARE
insert_string       VARCHAR;
BEGIN
	IF (usage_string = ''  OR usage_string = 'help' OR usage_string = '?') THEN
    insert_string := '' || 
    E'Summary \n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' Functionality: Calculate Huber-White robust statistics for logistic regression\n' || 	
    E' The function first runs the regression to calculate the \n' ||
    E'     coefficients and uses them to calculate the robust statistics \n' || 	
    E' The functions robust_variance_linregr() and robust_variance_logregr() have nearly identical interfaces\n' || 	
    E' SELECT {schema_madlib}.robust_variance_logregr(''source_table'' \n' || 
    E'                                       ,''output_table'' \n' || 
    E'                                       ,''dependent_variable'' \n' || 
    E'                                       ,''independent_variable'' \n' ||
    E'                                       ,''group_cols'' \n' ||
    E'                                       ,''max_iter'' \n' ||
    E'                                       ,''optimizer'' \n' ||
    E'                                       ,''tolerance'' \n' ||
    E'                                       ,''print_warnings'' \n' ||
    E'                                       );\n' || 
    E'For more details on function usage:  \n' || 
    E'SELECT {schema_madlib}.robust_variance_logregr(''usage'') \n';
  ElSIF (usage_string  = 'usage') THEN
    insert_string := '' || 
    E'Usage\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' To use this function  \n' || 	
    E' SELECT {schema_madlib}.robust_variance_logregr( \n' ||
    E' ''source_table'',         -- Name of data table          \n' || 
    E' ''output_table'',         -- Name of result table \n' || 
    E' ''dependent_variable'',   -- Name of column for dependent variables\n' || 
    E' ''independent_variable'', -- Name of column for independent variables\n' || 
    E'                               (can be any SQL expression that evaluates to an array) \n' || 
    E' ''group_cols'',           -- [OPTIONAL] Comma separated string with columns to group by.  Default is NULL. \n' || 
    E' ''max_iter'',           -- [OPTIONAL] The number of iterations used by the logistic regression solver.  Default is 20. \n' || 
    E' ''optimizer'',           -- [OPTIONAL] Name of the optimizer used in the logistic regression.  Default is irls. \n' || 
    E' ''tolerance'',           -- [OPTIONAL] The tolerance of the logistic regression optimizer.  Default is 0.0001. \n' || 
    E' ''print_warnings'',         -- [OPTIONAL] Should the optimizer print warning messages to the screen.  Default is FALSE. \n' || 

    E' );\n' || 
    E'\n' || 
    E'Output:\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' The output table (''output_table'' above) has the following columns\n' || 	
    E' ''coef''    DOUBLE PRECISION[],  -- Coefficients of regression \n' || 
    E' ''std_err''  DOUBLE PRECISION[], -- Huber-White standard errors\n' || 
    E' ''stats''    DOUBLE PRECISION[], -- Z-stats of the standard errors\n' || 
    E' ''p_values'' DOUBLE PRECISION[], -- p-values of the standard errors\n' || 
    E'\n' || 
    E'';
  ELSE
    insert_string := 'No such option. Run SELECT {schema_madlib}.robust_variance_logregr()';
  END IF;
  RETURN insert_string;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr()
RETURNS VARCHAR AS $$
BEGIN
  RETURN MADLIB_SCHEMA.robust_variance_logregr('');
END;
$$ LANGUAGE plpgsql VOLATILE;




/**
  @brief Functions for the various robust regression analyzes.  Both robust logistic and robust linear take identical arguments for the first five parameters. The logistic regression has an additional 4 optional parameters that specify the details of the regression fit.   
 *
 * @param source_table String identifying the input table
 * @param out_table String identifying the output table to be created
 * @param dependent_varname Column containing the dependent variable
 * @param independent_varname Column containing the array of independent variables
 * @param coef [OPTIONAL] Column containing the array of the coefficients, or NULL.
 * For logistic regression, there are also 
 * @param max_iter [OPTIONAL] Integre identifying the maximum iterations used by the logistic regression solver.  Default is 20.
 * @param optimizer [OPTIONAL] String identifying the optimizer used in the logistic regression.  See the documentation in the logistic regression for the available options.  Default is irls.
 * @param tolerance [OPTIONAL] Float identifying the tolerance of the logistic regression optimizer. Default is 0.0001. 
 * @param print_warnings [OPTIONAL] Boolean specifying if the regression fit should print any warning messages.  Default is false.  
 * @par
 * To include an intercept in the model, set one coordinate in the
 * <tt>independentVariables</tt> array to 1.
 *
 * @return A composite value:
 *  - <tt>std_err FLOAT8[]</tt> - Array of huber-white standard errors,
 *    \f$ \mathit{se}(c_1), \dots, \mathit{se}(c_k) \f$
 *  - <tt>t_stats FLOAT8[]</tt> - Array of t-statistics, \f$ \boldsymbol t \f$
 *  - <tt>p_values FLOAT8[]</tt> - Array of p-values, \f$ \boldsymbol p \f$
 *
 * @usage
 * For function summary information. Run 
 * sql> select robust_variance_logregr('help');
 * OR
 * sql> select robust_variance_logregr();
 * OR
 * sql> select robust_variance_logregr('?');
 * For function usage information. Run 
 * sql> select robust_variance_logregr('usage');
 *  - Compute the coefficients, and the get the robust diagnostic statistics:
 * 	<pre> 
 *  select robust_variance_logregr(source_table, out_table, regression_type, dependentVariable, independentVariables, NULL );
 * </pre>
 *
 *  - If the coefficients are already known, they can be provided directly
 *    <pre>select robust_variance_logregr(source_table, out_table, regression_type, dependentVariable, independentVariables, coef );
 </pre>
 */


/**
  * @brief Robust logistic regression with default fit regression behavior, and no grouping,
 **/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_logregr(
	source_table,
	out_table,
	dependent_variable,
	independent_variable,
	NULL, 
	20, 
	'irls',
	0.0001,
	FALSE);
END;
$$ LANGUAGE plpgsql VOLATILE;


CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
   , input_group_cols			VARCHAR       -- grouping columns
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_logregr(
	source_table,
	out_table,
	dependent_variable,
	independent_variable,
	input_group_cols, 
	20, 
	'irls',
	0.0001,
	FALSE);
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
   , input_group_cols			VARCHAR       -- grouping columns
   , max_iter            		INTEGER		  -- max number of iterations
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_logregr(
	source_table,
	out_table,
	dependent_variable,
	independent_variable,
	input_group_cols, 
	max_iter, 
	'irls',
	0.0001,
	FALSE);
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
   , input_group_cols			VARCHAR       -- grouping columns
   , max_iter            		INTEGER		  -- max number of iterations
   , optimizer           		VARCHAR		  -- The optimizer used in the robust regression
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_logregr(
	source_table,
	out_table,
	dependent_variable,
	independent_variable,
	input_group_cols, 
	max_iter, 
	optimizer,
	0.0001,
	FALSE);
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
     source_table               VARCHAR       -- name of input  table
   , out_table                  VARCHAR       -- name of output table
   , dependent_variable         VARCHAR       -- name of dependent variable
   , independent_variable       VARCHAR       -- name of independent variable
   , input_group_cols			VARCHAR       -- grouping columns
   , max_iter            		INTEGER		  -- max number of iterations
   , optimizer           		VARCHAR		  -- The optimizer used in the robust regression
   , tolerance           		DOUBLE PRECISION -- The tolerance of the optimizer
  )
RETURNS VOID AS $$
BEGIN
  PERFORM MADLIB_SCHEMA.robust_variance_logregr(
	source_table,
	out_table,
	dependent_variable,
	independent_variable,
	input_group_cols, 
	max_iter, 
	optimizer,
	tolerance,
	FALSE);
END;
$$ LANGUAGE plpgsql VOLATILE;


--------------------------- Robust Logistic Regression ----------------------------------

/**
  * @brief Robust logistic function subcall
 **/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_logregr(
	  source_table               VARCHAR       -- name of input  table
	, out_table                  VARCHAR       -- name of output table
	, dependent_varname          VARCHAR       -- name of dependent variable
	, input_independent_varname        VARCHAR       -- name of independent variable
	, input_group_cols           VARCHAR       -- grouping columns
	, max_iter            INTEGER			   -- maximum of iterations in the optimizer
	, optimizer           VARCHAR			   -- the optimizer used
	, tolerance           DOUBLE PRECISION
	, print_warnings             BOOLEAN
  )
RETURNS VOID AS $$
DECLARE
  insert_string               VARCHAR;
  group_cols                  VARCHAR[];
  regr_coef		      	        DOUBLE PRECISION[];
  table_creation_string       VARCHAR;
  group_string                VARCHAR;
  where_group_string          VARCHAR;
  actual_table_name           VARCHAR;
  input_table_name            VARCHAR[];
  group_array_length          INTEGER;
  each_group                  INTEGER;
  robust_logregr_fitting_rst  VARCHAR;
  temp_table                  VARCHAR;
  col_data_type               VARCHAR;
  schema_name                 VARCHAR;
  sql                         VARCHAR;
  tempTableName			          VARCHAR;
  robust_log_rst		          MADLIB_SCHEMA.robust_logregr_result;
  old_msg_level         TEXT;
  independent_varname   VARCHAR;
  print_warningsString VARCHAR;
BEGIN
	EXECUTE 'SELECT setting FROM pg_settings WHERE name=''client_min_messages''' INTO old_msg_level;
	EXECUTE 'SET client_min_messages TO warning';
  	
	PERFORM MADLIB_SCHEMA.robust_input_checking(source_table, out_table, dependent_varname, input_independent_varname);

	independent_varname := input_independent_varname; 
	
	--This code should be added back in should '*' support be implemented
  /*IF (input_independent_varname = '*') THEN
	  independent_varname := MADLIB_SCHEMA.__internal_get_col_names_except_dep_variable(source_table, input_independent_varname);
	ELSE
	  independent_varname := input_independent_varname; 
  	END IF;*/
	
    IF (input_group_cols IS NULL)
	THEN
		-- create output table with appropriate column names
		EXECUTE '
		CREATE TABLE ' || out_table || ' (
			coef DOUBLE PRECISION[],
			std_err DOUBLE PRECISION[],
			z_stats DOUBLE PRECISION[],
			p_values DOUBLE PRECISION[])';
		-- Run the regression if the coefficients are not provided 
		print_warningsString := 'FALSE';
		IF(print_warnings IS TRUE)
		THEN
			print_warningsString := 'TRUE';
		END IF;
		tempTableName := MADLIB_SCHEMA.__unique_string(); 
		EXECUTE '
			SELECT MADLIB_SCHEMA.logregr_train('
				  || ' '''||source_table||''' ' || ','
				  || ' '''||tempTableName||''' ' || ','
				  || ' '''||dependent_varname ||''' ' || ' , '
				  || ' '''||independent_varname||''' '||' , '
				  || 'NULL'||  ' , '
				  ||max_iter || ' , '
				  || ' '''||optimizer|| ''' '|| ' , '
				  || tolerance||' , '
				  || print_warningsString||
				   ')';
		EXECUTE 'SELECT coef from ' || tempTableName INTO regr_coef;

		EXECUTE 'DROP TABLE IF EXISTS ' || tempTableName;

			
		-- compute robust variance calculation
		robust_log_rst := MADLIB_SCHEMA.__internal_get_robust_logregr_result(
						source_table, dependent_varname, independent_varname, regr_coef);
			insert_string := MADLIB_SCHEMA.__internal_get_robust_logregr_insert_string(
						robust_log_rst, out_table);
		-- Ensure Infinity and NaN are cast properly
		insert_string := REGEXP_REPLACE(insert_string, 'Infinity', 
										'''Infinity''::double precision', 'gi');
		insert_string := REGEXP_REPLACE(insert_string, 'NaN', 
										'''NaN''::double precision', 'gi');
			-- complete the sql string and execute
			EXECUTE insert_string || ')';

  ELSE

    -------------------------------------------------------------------------
    -- Grouping columns: Run robust variance estimates for each group
    -------------------------------------------------------------------------
    
    -- Step 1: Prepare the group columns 
    -------------------------------------------------------------------------
    group_cols = MADLIB_SCHEMA._string_to_array(input_group_cols);
    group_array_length = array_upper(group_cols, 1);

    input_table_name = regexp_split_to_array(source_table, E'\\.');
    IF array_upper(input_table_name, 1) = 1 THEN
      actual_table_name = input_table_name[1];
      schema_name  := current_schema();
    ELSIF array_upper(input_table_name, 1) = 2 THEN
      actual_table_name = input_table_name[2];
      schema_name  = input_table_name[1];
    ELSE
      RAISE EXCEPTION 'Incorrect input source table name provided';
    END IF;

    -- Check that each grouping column exists
    FOR each_group in 1 .. group_array_length
    LOOP
      if NOT MADLIB_SCHEMA.check_if_col_exists(source_table, 
                                    group_cols[each_group]) THEN
            RAISE EXCEPTION 'Grouping column % does not exist', 
                                    group_cols[each_group];
      END IF;
    END LOOP;

    table_creation_string := 'CREATE TABLE ' || out_table || '(';
    FOR each_group in 1 .. group_array_length
    LOOP
        -- create a string that makes list of
        EXECUTE 'SELECT data_type FROM information_schema.columns
                 WHERE
                      table_schema = ''' || schema_name || '''
                      AND table_name = ''' || actual_table_name || '''
                      AND column_name= ''' || group_cols[each_group] || ''''
        INTO col_data_type;

        table_creation_string := table_creation_string
                                || group_cols[each_group]
                                || ' ' || col_data_type || ',';
    END LOOP;
   
    -- finish creating the output table
    EXECUTE table_creation_string || '
            coef DOUBLE PRECISION[],
            std_err DOUBLE PRECISION[],
            z_stats DOUBLE PRECISION[],
            p_values DOUBLE PRECISION[])';
    
    -- Step 2: Perform the regression on groups
    -------------------------------------------------------------------------
		temp_table := MADLIB_SCHEMA.__unique_string(); 
    PERFORM MADLIB_SCHEMA.logregr_train(source_table, 
                                        temp_table,
                                        dependent_varname,
                                        independent_varname,
                                        input_group_cols,
                                        max_iter,
                                        optimizer,
                                        tolerance,
                                        print_warnings);
    
    -- Note: We need to alter the names on the output tables for logregr_train
    -- so that they don't clash with the robust_variance_logregr output tables
    -- This name changing is required to construct queries when the regressor
    -- is also being grouped by. I don't know why anyone would do that but 
    -- it should be a mathematically valid operation.
    FOR each_group in 1 .. group_array_length
    LOOP
        EXECUTE 'ALTER TABLE ' || temp_table || ' RENAME COLUMN ' || 
                 group_cols[each_group] || ' TO log_regr_' 
                || group_cols[each_group];
    END LOOP;
                                    
    -- Step 3: Prepare the grouping strings 
    group_string := '';
    FOR each_group in 1 .. (group_array_length-1)
    LOOP
        group_string := group_string || 
                        actual_table_name || '.' || 
                        group_cols[each_group] || ',';
    END LOOP;
    group_string := group_string || 
                    actual_table_name || '.' || 
                    group_cols[group_array_length];

    -- Where clause string
    where_group_string := '';
    FOR each_group in 1 .. (group_array_length-1)
    LOOP
        where_group_string := where_group_string || '(' || 
                        temp_table || '.log_regr_' || 
                        group_cols[each_group] || ' = ' || 
                        actual_table_name || '.' || 
                        group_cols[each_group] || ') AND ';
    END LOOP;
    where_group_string := where_group_string || '(' || 
                    temp_table || '.log_regr_' || 
                    group_cols[group_array_length] || ' = ' || 
                    actual_table_name || '.' || 
                    group_cols[group_array_length] || ')';

    -- Step 4: Robust statistics into the out table 
    EXECUTE 
      'INSERT INTO ' || out_table || '
        SELECT ' || group_string || ', (result).coef, (result).std_err,
                                       (result).z_stats, (result).p_values
        FROM (
            SELECT
                '|| group_string ||',
                MADLIB_SCHEMA.robust_logregr('|| 
                    dependent_varname ||','|| 
                    independent_varname || ', coef) AS result' || 
            ' FROM '|| source_table || ',' || temp_table || 
            ' WHERE '|| where_group_string ||
            ' GROUP BY '|| group_string || ')' || actual_table_name;
    EXECUTE 'DROP TABLE IF EXISTS ' || temp_table;
  END IF;
  --Restore message settings
  EXECUTE 'SET client_min_messages TO '|| old_msg_level;

END;
$$ LANGUAGE plpgsql VOLATILE;


--------------------------- ROBUST MULTINOMIAL LOGISTIC REGRESSION -------------------------

CREATE TYPE MADLIB_SCHEMA.robust_mlogregr_result AS (
    ref_category    INTEGER,
    coef            DOUBLE PRECISION[],
    std_err         DOUBLE PRECISION[],
    z_stats         DOUBLE PRECISION[],
    p_values        DOUBLE PRECISION[]
);

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_transition
(
    state           DOUBLE PRECISION[],
    y               INTEGER,
    numCategories   INTEGER,
    ref_category    INTEGER,
    x               DOUBLE PRECISION[],
    coef            DOUBLE PRECISION[]
)
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_merge_states
(
    state1  DOUBLE PRECISION[],
    state2  DOUBLE PRECISION[]
)
RETURNS DOUBLE PRECISION[]
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.mlogregr_robust_step_final
(
    state DOUBLE PRECISION[]
)
RETURNS MADLIB_SCHEMA.robust_mlogregr_result
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT; 

/**
 * @brief Compute robust regression diagnostic statistics for multinomial logistic regression.
 *
 * @param dependentVariable Column containing the dependent variable
 * @param independentVariables Column containing the array of independent variables
 * @param coef Column containing the array of the  coefficients (as obtained by logregr)
 *
 * @par
 * To include an intercept in the model, set one coordinate in the
 * <tt>independentVariables</tt> array to 1.
 *
 * @return A composite value:
 *  - <tt>ref_category INTEGER</tt> - The reference category 
 *  - <tt>coef FLOAT8[] </tt> - The coefficients for the regression
 *  - <tt>std_err FLOAT8[]</tt> - Array of huber-white standard errors,
 *    \f$ \mathit{se}(c_1), \dots, \mathit{se}(c_k) \f$
 *  - <tt>t_stats FLOAT8[]</tt> - Array of t-statistics, \f$ \boldsymbol t \f$
 *  - <tt>p_values FLOAT8[]</tt> - Array of p-values, \f$ \boldsymbol p \f$
 *
 * @usage
 *  - Get all the diagnostic statistics:\n
 *
 *  <pre> SELECT robust_mlogregr(<em>dependentVariable</em>,
 *	<em>independentVariables</em>, coef)
 *	FROM <em>dataTable</em>; 
 * </pre>
 */
CREATE AGGREGATE MADLIB_SCHEMA.robust_mlogregr(
	INTEGER             /*+ "y" */,
	INTEGER             /*+ "numCategories" */, 
	INTEGER             /*+ "ref_category" */, 
	DOUBLE PRECISION[]  /*+ "x" */, 
    DOUBLE PRECISION[]  /*+ "coef" */
)
(
    STYPE=DOUBLE PRECISION[],
    SFUNC=MADLIB_SCHEMA.mlogregr_robust_step_transition,
    m4_ifdef(`GREENPLUM',`prefunc=MADLIB_SCHEMA.mlogregr_robust_step_merge_states,')
    FINALFUNC=MADLIB_SCHEMA.mlogregr_robust_step_final,
    INITCOND='{0,0,0,0,0}'
);




--------------------------- INTERNAL ---------------------------------------
/**
  * @brief Return robust multinomial logistic regression estimates given a set of coefficients
**/
--CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_mlogregr_result(
--    source_table        VARCHAR,       -- name of input  table
--    dependent_varname   VARCHAR,       -- name of dependent variable
--    num_category        INTEGER,       -- number of categories
--    ref_category        INTEGER,       -- reference category
--    independent_varname VARCHAR,       -- name of independent variable
--    mlogregr_coeffs     DOUBLE PRECISION[]  -- coeffs from logear regression
--)
--RETURNS MADLIB_SCHEMA.robust_mlogregr_result AS $$
--DECLARE
--    robust_value MADLIB_SCHEMA.robust_mlogregr_result;
--BEGIN
--	EXECUTE '
--    SELECT (MADLIB_SCHEMA.robust_mlogregr('
--          || dependent_varname    || ', '
--          || num_category || ', '
--          || ref_category || ', '
--          || independent_varname  || ' , '
--          || 'ARRAY[' || array_to_string(mlogregr_coeffs, ',') || '])).* FROM ' || source_table
--	INTO robust_value;
--    RETURN robust_value;
--END
--$$ LANGUAGE plpgsql;

/**
  * @brief Return insert string for robust multinomial logistic regression 
**/
CREATE FUNCTION MADLIB_SCHEMA.__internal_get_robust_mlogregr_insert_string(
    robust_mlog_rst MADLIB_SCHEMA.robust_mlogregr_result,
    out_table TEXT
)
RETURNS VARCHAR AS $$
DECLARE 
  insert_string VARCHAR;
BEGIN
  insert_string := 'INSERT INTO ' || out_table || ' VALUES ('; 
  insert_string := insert_string  || 
            (robust_mlog_rst).ref_category || ', ' ||  
            CASE 
              WHEN (robust_mlog_rst).coef is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_mlog_rst).coef, ',')     || '], '
            END             || 
            CASE 
              WHEN (robust_mlog_rst).std_err is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_mlog_rst).std_err, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_mlog_rst).z_stats is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_mlog_rst).z_stats, ',')  || '], '
            END             ||
            CASE 
              WHEN (robust_mlog_rst).p_values is NULL
              THEN '''{}'','
              ELSE 'ARRAY[' || array_to_string((robust_mlog_rst).p_values, ',') || '] '
            END;
  RETURN insert_string; 
END;
$$ LANGUAGE plpgsql VOLATILE;

--------------------------- Interface ----------------------------------




CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_mlogregr(
     usage_string VARCHAR                               -- usage string
)
RETURNS VARCHAR AS $$
DECLARE
insert_string       VARCHAR;
BEGIN
	IF (usage_string = ''  OR usage_string = 'help' OR usage_string = '?') THEN
    insert_string := '' || 
    E'Summary \n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' Functionality: Calculate Huber-White robust statistics for multinomial logistic regression\n' || 	
    E' The function first runs the regression to calculate the \n' ||
    E'     coefficients and uses them to calculate the robust statistics \n' || 	
    E' SELECT {schema_madlib}.robust_variance_mlogregr(''source_table'' \n' || 
    E'                                       ,''output_table'' \n' || 
    E'                                       ,''dependent_variable'' \n' || 
    E'                                       ,''independent_variable'' \n' ||
    E'                                       ,''reference_category'' \n' ||
    E'                                       ,''group_cols'' \n' ||
    E'                                       );\n' || 
    E'For more details on function usage:  \n' || 
    E'SELECT {schema_madlib}.robust_variance_mlogregr(''usage'') \n';
  ElSIF (usage_string  = 'usage') THEN
    insert_string := '' || 
    E'Usage\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' To use this function  \n' || 	
    E' SELECT {schema_madlib}.robust_variance_mlogregr( \n' ||
    E' ''source_table'',         -- Name of data table          \n' || 
    E' ''output_table'',         -- Name of result table\n' || 
    E' ''dependent_variable'',   -- Name of column for dependent variables\n' || 
    E' ''independent_variable'', -- Name of column for independent variables\n' || 
    E'                               (can be any SQL expression that evaluates to an array) \n' || 
    E' ''reference_category'',   -- [OPTIONAL] Reference category. Default is 0. \n' || 
    E' ''group_cols''            -- [OPTIONAL] Comma separated string with columns to group by.  Default is NULL. \n' || 
    E' );\n' || 
    E'\n' || 
    E'Output:\n' || 	
    E'-----------------------------------------------------------------------------------------\n' ||
    E' The output table (''output_table'' above) has the following columns\n' || 	
    E' ''coef''    DOUBLE PRECISION[],  -- Coefficients of regression \n' || 
    E' ''std_err''  DOUBLE PRECISION[], -- Huber-White standard errors\n' || 
    E' ''z-stats''    DOUBLE PRECISION[], -- Z-stats of the standard errors\n' || 
    E' ''p_values'' DOUBLE PRECISION[], -- p-values of the standard errors\n' || 
    E'\n' || 
    E'';
  ELSE
    insert_string := 'No such option. Run SELECT {schema_madlib}.robust_variance_mlogregr()';
  END IF;
  RETURN insert_string;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_mlogregr()
RETURNS VARCHAR AS $$
BEGIN
  RETURN MADLIB_SCHEMA.robust_variance_mlogregr('');
END;
$$ LANGUAGE plpgsql VOLATILE;












--------------------------- Robust Multinomial Logistic Regression ----------------------------------
/**
  * @brief Robust multinomial logistic function subcall
 **/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_mlogregr(
    source_table        VARCHAR,       -- name of input table
    out_table           VARCHAR,       -- name of output table
    dependent_varname   VARCHAR,       -- name of dependent variable
    independent_varname VARCHAR,       -- name of independent variable
    ref_category        INTEGER,       -- reference category
    input_group_cols    VARCHAR        -- grouping columns (PLACEHOLDER) 
)
RETURNS VOID AS $$
DECLARE
    num_category    INTEGER;
    regr_coef       DOUBLE PRECISION[];
    robust_value    MADLIB_SCHEMA.robust_mlogregr_result;
    insert_string   VARCHAR;
    old_msg_level   VARCHAR;
BEGIN
    EXECUTE 'SELECT setting FROM pg_settings WHERE name=''client_min_messages''' INTO old_msg_level;
    EXECUTE 'SET client_min_messages TO warning';
  	
    PERFORM MADLIB_SCHEMA.robust_input_checking(source_table, out_table, dependent_varname, independent_varname);	
	    -- Run the regression if the coefficients are not provided 
        -- Will do further parameter checking in the regression function
        EXECUTE
            $sql$SELECT coef FROM MADLIB_SCHEMA.mlogregr('$sql$ 
                || source_table || $sql$', '$sql$ 
                || dependent_varname || $sql$', '$sql$ 
                || independent_varname || $sql$', $sql$ 
                || 20 || $sql$, $sql$
                || $sql$'irls', $sql$  
                || 0.0001 || ','
                || ref_category || ')' 
        INTO regr_coef; 

        EXECUTE 
            'SELECT count(DISTINCT ' || dependent_varname|| ') FROM ' ||
                textin(regclassout(source_table))
        INTO num_category;

        -- compute robust variance calculation
        --robust_log_rst := MADLIB_SCHEMA.__internal_get_robust_mlogregr_result(
        --    source_table, dependent_varname, num_category, ref_category,
        --    independent_varname, regr_coef);
        EXECUTE 
            'SELECT (MADLIB_SCHEMA.robust_mlogregr('
                || dependent_varname    || ', '
                || num_category || ', '
                || ref_category || ', '
                || independent_varname  || ', '
                || 'ARRAY[' || array_to_string(regr_coef, ',') ||
                '])).* FROM ' || source_table
        INTO robust_value;
        insert_string :=
            MADLIB_SCHEMA.__internal_get_robust_mlogregr_insert_string(
                robust_value, out_table);

        -- Ensure Infinity and NaN are cast properly
        insert_string := REGEXP_REPLACE(
            insert_string, 'Infinity', '''Infinity''::double precision', 'gi');
        insert_string := REGEXP_REPLACE(
            insert_string, 'NaN', '''NaN''::double precision', 'gi');
            
        -- create output table with appropriate column names
        EXECUTE 
            'CREATE TABLE ' || out_table || ' (
                ref_category    INTEGER,
                coef            DOUBLE PRECISION[],
                std_err         DOUBLE PRECISION[],
                z_stats         DOUBLE PRECISION[],
                p_values        DOUBLE PRECISION[])';

        -- complete the sql string and execute
	    EXECUTE insert_string || ')'; 

    --Restore message settings
    EXECUTE 'SET client_min_messages TO '|| old_msg_level;
END;
$$ LANGUAGE plpgsql VOLATILE;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_mlogregr(
    source_table        VARCHAR,       -- name of input table
    out_table           VARCHAR,       -- name of output table
    dependent_varname   VARCHAR,       -- name of dependent variable
    independent_varname VARCHAR,       -- name of independent variable
    ref_category        INTEGER        -- reference category
)
RETURNS VOID AS $$
    SELECT MADLIB_SCHEMA.robust_variance_mlogregr($1, $2, $3, $4, $5, NULL);
$$ LANGUAGE sql;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.robust_variance_mlogregr(
    source_table        VARCHAR,       -- name of input table
    out_table           VARCHAR,       -- name of output table
    dependent_varname   VARCHAR,       -- name of dependent variable
    independent_varname VARCHAR        -- name of independent variable
)
RETURNS VOID AS $$
    SELECT MADLIB_SCHEMA.robust_variance_mlogregr($1, $2, $3, $4, 0, NULL);
$$ LANGUAGE sql;
